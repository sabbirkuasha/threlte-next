<!--
Auto-generated by: https://github.com/threlte/threlte/tree/main/packages/gltf
Command: npx @threlte/gltf@1.0.0-next.13 ./ClothHashHash.glb
-->

<script>
	import { Group } from 'three';
	import { T, forwardEventHandlers } from '@threlte/core';
	import { useGltf } from '@threlte/extras';
	import { useTexture } from '@threlte/extras';
	import * as THREE from 'three';

	export const ref = new Group();

	const gltf = useGltf('/ClothHashHash.glb');
	// --------------------------------------------------------Custom code
	const cloth_baseColor = useTexture('/export/Untitled material_BaseColor.jpg');
	const cloth_normal = useTexture('/export/Untitled material_Normal.jpg');
	const cloth_roughnessMap = useTexture('/export/Untitled material_Roughness.jpg');
	const cloth_opacity = useTexture('/export/Untitled material_Opacity.jpg');
	const cloth_height = useTexture('/export/Untitled material_Height.jpg');
	const cloth_AO = useTexture('/export/Untitled material_AmbientOcclusion.jpg');

	// $: $cloth_height ? console.log($cloth_height) : 'false';

	const vertexShader = `
  varying vec2 vUv;

  void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`;

	const fragmentShader = `
  uniform sampler2D baseTexture;
  uniform sampler2D heightTexture;
  varying vec2 vUv;

  void main() {
    float height = texture2D(heightTexture, vUv).r;
    vec2 uv = vUv + (vec2(0.5) - vUv) * height * 0.04;
    vec4 outColor = texture2D(baseTexture, uv);
    gl_FragColor = outColor;
  }
`;

	let materialz = new THREE.ShaderMaterial({
		uniforms: {
			baseTexture: { type: 't', value: $cloth_baseColor },
			heightTexture: { type: 't', value: $cloth_height }
		},
		vertexShader: vertexShader,
		fragmentShader: fragmentShader
	});

	$: $gltf
		? addItem($gltf, $cloth_height, $cloth_opacity, $cloth_AO, $cloth_roughnessMap)
		: 'false';

	function addItem(item, height, opa, ao, rough) {
		// Settings
		item.materials.ClothM.transparent = true;
		item.materials.ClothM.alphaToCoverage = true;
		item.materials.ClothM.blendEquation = 0;
		item.materials.ClothM.dithering = true;
		item.materials.ClothM.side = 2;
		item.materials.ClothM._alphaTest = 1;

		item.materials.ClothM.displacementMap = height;
		item.materials.ClothM.aoMap = ao;
		// item.materials.ClothM.alphaMap = opa;
		item.materials.ClothM.roughnessMap = rough;

		item.materials.ClothM.displacementScale = 1;

		console.log($gltf);
	}
	// --------------------------------------------------------Custom code

	const component = forwardEventHandlers();
</script>

<T is={ref} dispose={false} {...$$restProps} bind:this={$component}>
	{#await gltf}
		<slot name="fallback" />
	{:then gltf}
		<!-- <T.Mesh
			geometry={gltf.nodes.Cloth.geometry}
			material={gltf.materials.ClothM}
			position={[0, 0.4, 0]}
			scale={0.01}
		/> -->

		<!-- Cutom Code -->
		<!-- <T.Mesh
			geometry={gltf.nodes.Cloth.geometry}
			material={gltf.materials.ClothM}
			position={[0, 0.4, 0]}
			scale={0.01}
		/> -->
		<!-- Cutom Code -->
		<T.Mesh
			geometry={gltf.nodes.Cloth.geometry}
			material={materialz}
			position={[0, 0.4, 0]}
			scale={0.01}
		/>

		<!-- Test 002 - Inject UV inside MeshPhysicalMaterial -->
	{:catch error}
		<slot name="error" {error} />
	{/await}

	<slot {ref} />
</T>
